<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="编译原理第三章笔记——语法分析, SYH的博客">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>编译原理第三章笔记——语法分析 | SYH的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.1.1"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">SYH的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">SYH的博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">编译原理第三章笔记——语法分析</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
                                <span class="chip bg-color">编译原理</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-09-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-09-26
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    29 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="编译原理第三章笔记——语法分析"><a href="#编译原理第三章笔记——语法分析" class="headerlink" title="编译原理第三章笔记——语法分析"></a>编译原理第三章笔记——语法分析</h1><p>下面是这篇笔记的思维导图：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/11.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/11.png" alt="img"></a></p>
<p>注意：以下的所有分析基于上下文无关文法。</p>
<h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. 语法分析</h3><h4 id="1-1-语法分析器"><a href="#1-1-语法分析器" class="headerlink" title="1.1 语法分析器"></a>1.1 语法分析器</h4><p>在词法分析中，我们扫描输入源程序的每个字符，得到多种类型的单词（token），一系列的单词就构成了一条单词流。可以设想，单词流的某个部分有多个并排的单词，它们可能会构成某个句子，但是这个句子是否真的符合语法规则呢？我们需要借助语法分析器才能进行判断。更直接点，我们可以说语法分析器是用来判断<strong>句子是否符合某个给定的上下文无关文法</strong>的。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/1.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/1.png" alt="img"></a></p>
<h4 id="1-2-语法分析的方法"><a href="#1-2-语法分析的方法" class="headerlink" title="1.2 语法分析的方法"></a>1.2 语法分析的方法</h4><p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/2.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/2.png" alt="img"></a></p>
<p>本篇笔记主要讲解自顶向下语法分析。要判断句子是否符合某个给定的上下文无关文法，可以尝试从文法的开始符号出发，若经过一系列推导之后可以得到完全匹配原句子的句子，则可以说原句子来自于给定的文法。</p>
<h3 id="2-自顶向下语法分析存在的问题"><a href="#2-自顶向下语法分析存在的问题" class="headerlink" title="2. 自顶向下语法分析存在的问题"></a>2. 自顶向下语法分析存在的问题</h3><p>自顶向下分析的核心思路是：对任何需要分析的输入串，从文法的开始符号出发，试图用一切可能的方法，结合文法的产生式，自上而下地构造一棵基于输入串的语法树。但在这个过程中存在着一个问题，这个问题概况地说就是<strong>文法的不确定性</strong>。为什么说具有一种不确定性呢？我们可以从以下三个方面一一分析。</p>
<h4 id="2-1-左递归"><a href="#2-1-左递归" class="headerlink" title="2.1 左递归"></a>2.1 左递归</h4><p><strong>① 定义</strong></p>
<p>其一，文法存在的左递归带来了不确定性。</p>
<p>如果一个文法存在非终结符 P 使得 P +⇒ Pa，那么这个文法就是含有左递归的。它的意思其实是说，当我们试图用 P 的右部去替换 P 这个非终结符的时候，替换得到的结果再次含有 P，若此时无法匹配输入的字符，则我们不得不对 P 进行又一轮的替换，反反复复，陷入了无限循环，始终没有找到递归的出口。</p>
<p><strong>② 消除</strong></p>
<p>我们并不希望一个文法存在不确定性，所以需要想办法消除文法的左递归。对于简单的左递归，我们的消除规则如下：若存在递归产生式 <code>P → Pα|β</code>，则将其改写为：<code>P → βP‘</code>，<code>P’ → αP‘| ε</code>。</p>
<p>比如说存在如下的文法：</p>
<pre class="line-numbers language-js"><code class="language-js">E →  E <span class="token operator">+</span> T<span class="token operator">|</span>T
T → T <span class="token operator">*</span> F<span class="token operator">|</span>F
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>它的第一条和第二条产生式都是递归的，需要消除递归。将产生式与规则一一对应，那么 <code>+T</code> 就代表 <code>α</code>，T 就代表 <code>β</code>，所以 <code>E → E + T|T</code> 改写为 <code>E → TE&#39;</code> 和 <code>E&#39;→ +TE&#39;|ε</code>；同理，<code>*F</code> 代表 <code>α</code>，F 代表 <code>β</code>，所以 <code>T → T * F|F</code> 就改写为 <code>T → FT&#39;</code> 和 <code>T → *FT&#39;|ε</code>。</p>
<p><strong>这样的转换实际上就是把左递归转换成了右递归。</strong></p>
<p>对于更一般性的左递归，我们的消除规则如下：若存在递归产生式 <code>P → Pα1|Pα2|...|Pαm|β1|β2|β3|βn</code>（右部的一部分含左部，一部分不含），则将其改写为：<code>P → |β1P&#39;|β2P&#39;|...|βnP&#39;</code> 和 <code>P’ → α1P&#39;|α2P‘|...|αmP’| ε</code></p>
<p>比如说存在如下的文法：</p>
<pre class="line-numbers language-js"><code class="language-js">S → Qc<span class="token operator">|</span>c
Q → Rb<span class="token operator">|</span>b
R → Sa<span class="token operator">|</span>a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>看起来它似乎不是左递归文法，但其实经过 <code>S ⇒ Qc ⇒ Rbc ⇒ Sabc</code> 的推导后，会发现它其实也是左递归文法。这种不太明显的、需要经过替换才能体现递归性的，称之为<u>间接左递归</u>。我们将上面推导过程中使用过的产生式逆序排列，得到下面等价的文法：</p>
<pre class="line-numbers language-js"><code class="language-js">R → Sa<span class="token operator">|</span>a
Q → Rb<span class="token operator">|</span>b
S → Qc<span class="token operator">|</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如何消除左递归呢？首先将第一条产生式代入第二条，得到 <code>Q → Sab|ab|b</code>，它仍然不包含左递归，所以继续代入第三条，得到 <code>S → Sabc|abc|bc|c</code>，它包含<strong>直接左递归</strong>，所以按照前面说过的一般左递归的消除方法对其进行处理，得到 <code>S → (abc|bc|c)S&#39;</code> 和 <code>S‘ → abcS’|ε</code>。由于 Q 和 R 的相关产生式已经包含在里面，所以这两条产生式就构成了已经消除左递归的等价文法。</p>
<h4 id="2-2-回溯"><a href="#2-2-回溯" class="headerlink" title="2.2 回溯"></a>2.2 回溯</h4><p>其二，文法存在的回溯带来了不确定性。</p>
<p>比方说对于文法 <code>{Z → cAd,A → ab|a}</code> 以及输入符号串 <code>S = cad</code>，当 A 面对输入符号 a 的时候，到底应该用 <code>A → ab|a</code> 的第一个还是第二个右部去替换呢？看起来好像都可行，但若选取了第一个右部，则后面会发现 b 无法匹配 d，所以这个选取是错误的。我们需要<strong>回溯</strong>到 A 产生子树之前，令其产生 a 子树而不是 ab 子树。设想产生式的右部如果是 <code>ab|ac|ad|...|az</code>，是不是意味着我们需要做更多的尝试/回溯呢？<strong>这会大大降低语法分析的效率</strong>，而这是我们不希望看到的。所以有必要消除回溯。</p>
<p>在这之前，我们先考虑如何更加准确地判断某个文法是否存在回溯的情况。这里我们要引入一个 <strong>First 集</strong>的概念。</p>
<p><strong>① First</strong> 集</p>
<p>First 集又叫终结首符集，对<strong>非终结符 A 的每一个右部 m</strong> 都存在着一个 First 集，集合中的元素都是 m 的<strong>所有可能推导</strong>的开头终结符或者可能的 <code>ε</code>。比如上面的 <code>A → ab|a</code> ，A 的右部是 ab 或者 a，ab 或者 a 的推导（在这里是它们自身）的开头终结符就是 a，所以 <code>First(ab) = First(a) = {a}</code>。</p>
<p><strong>② 如何判断无回溯</strong></p>
<p>对于非终结符 A，它的每一个右部都会产生对应的 First 集，若这些集合两两不相交，即 <code>First(ai) ∩ First(aj) = Ø</code>，那么至少对于 A 而言，它是不存在回溯的。比如，<code>A → ab|cd|ef</code> ，每一个右部的 First 集两两之间都没有交集，那么 A 就是没有回溯的，当它面对一个输入符号（比方说 a，c，e）的时候，它可以确切地让一个右部去进行替换，而无需担心替换失败、需要回过头来选择其它右部的情况。</p>
<p><strong>③ 如何克服回溯</strong></p>
<p>不幸的是，大部分情况下，很多非终结符都存在回溯的情况。不过，我们可以通过提取左公因子来克服这种回溯。比如说产生式 <code>A → ab|ac|ad|...|az</code>，可以提取公因子 a，改写为 <code>A → a(b|c|d|...|z)</code>，再改写得到 <code>A → aX</code> 和 <code>X → (b|c|d|...|z)</code>。至少这个时候，对于 A 而言它已经不存在回溯的情况，毕竟它只有一个右部了。当然，对于 X，它依然可能存在回溯，比如说 b=mn，c = ml，诸如此类，若存在这种情况，我们就再次提取公因子。这样反复提取之后，我们可以确保所有非终结符的右部的 First 集都不存在交集，因此得以消除回溯。不过，这样的代价就是引入了大量的非终结符作为替换时的过渡。</p>
<h4 id="2-3-空符号串"><a href="#2-3-空符号串" class="headerlink" title="2.3 空符号串"></a>2.3 空符号串</h4><p>我们已经消除了左递归和回溯，这样文法是不是就真的确定了呢？其实不是，因为我们还得考虑空符号串的问题。简单地说，假设左部为非终结符 A 的产生式，它有一个右部是 <code>ε</code>，且 A 当前面对的输入符号为 a，那么到底要不要用 <code>ε</code> 去替换掉 A 呢？如果不使用 <code>ε</code>，至少说明了 A 存在其它右部足以处理输入符号 a，也许刚好就是 a，或者是以 a 开头的符号串；如果使用 <code>ε</code>，则意味着 A 放弃了处理 a 的任务，这其中隐含的意思是，<strong>A 自己无法处理 a，但是它确信在语法树中，排在自己右边的非终结符足以处理 a</strong>。不过，这样的非终结符是否确实存在？这时候，我们引入了另一个新的概念，即 Follow 集。</p>
<p><strong>① Follow</strong> 集</p>
<p>Follow 集又叫做后跟符号集，对<strong>某个非终结符 A</strong>存在着一个 Follow 集，<strong>集合中的所有元素都是开始符号 S 与 A 之间的相关推导中，紧跟着出现在 A 右边的终结符</strong>。比如说存在文法 <code>{S → Bc,B → Aa,A → de}</code>，要求 A 的 Follow 集，那么 S 与 A 之间就存在着一个相关推导为 <code>S → Aac</code>，紧跟着 A 后面的是终结符 a，所以 <code>Follow(A)={a}</code>；如果是要求 S 的 Follow 集呢？S 与 S 之间的相关推导就是 <code>S → S</code>，可以看到 S 右边没有紧跟着终结符，这时候我们就规定 <code>Follow(S)={ # }</code>。</p>
<p><strong>② 空符号串的处理</strong></p>
<p>有没有注意到 Follow 集的定义刚好与我们谈到的空符号串的处理有相关的地方？—— 空符号串 <code>ε</code> 如果被使用，说明语法树中 A 的右侧存在着另一个非终结符可以处理当前输入符号，而 <code>Follow(A)</code> 代表的又是语法推导中位于 A 的右侧的那些终结符，那么，<strong>重点来了</strong>，假设 <code>Follow(A)</code> 中刚好就包含当前输入符号，那么就说明 A 的推导的右侧存在着终结符 a，而这个 a 是由 A 右侧的非终结符推导得到的。换句话说，当 <code>Follow(A)</code> 中刚好就包含当前输入符号的时候，我们可以肯定，存在着某个非终结符可以处理当前输入符号，并使得 A 可以用空符号串 <code>ε</code> 进行代替，而无需去处理当前输入符号。</p>
<p>所以，我们通过求解 <code>Follow(A)</code> ，消除了<strong>考虑是否需要用空符号串替代 A</strong> 的不确定性。我们可以看下面这个例子再来理解一下。假定有文法：</p>
<pre class="line-numbers language-js"><code class="language-js">S → aA<span class="token operator">|</span>d
A → bAS<span class="token operator">|</span>ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>若输入符号串为 <code>abd</code>，尝试推导该符号串是否符合给定的文法：</p>
<ul>
<li>第一个输入符号是 a，程序经过判断，决定使用 <code>S → aA</code> 开始构造语法树，这样就处理了第一个输入符号 a；</li>
<li>第二个输入符号是 b，程序经过判断，决定使用 <code>A → bAS</code> 将 A 替换，这样就处理了第二个输入符号 b；</li>
<li>第三个输入符号是 d，程序此时如何判断呢？查看 <code>First(A)</code>，发现不包含 d，所以 A 是无法直接处理当前输入符号 d 的，那么它是否应该用 <code>ε</code> 替换掉，并让 S 去处理 d 呢？查看 <code>Follow(A)</code>，发现刚好是包含 d 的，所以这里用 <code>ε</code> 替换 A</li>
<li>当前输入符号还是 d，用 d 替换 S，成功处理完第三个输入符号 d。</li>
</ul>
<p><strong>③ 如果 First 集和 Follow 集有交集…….</strong></p>
<p>到了这里，可能会产生一个疑问：既然 A 的 First 集在某种程度上决定了非终结符 A 自身是否足以处理当前输入符号，而 A 的 Follow 集在某种程度上决定了 A 右侧的非终结符是否足以处理当前输入符号，那么如果 <code>First(A)</code> 和 <code>Follow(A)</code> 都包含了当前输入符号，好像就说明了 A 和右侧非终结符都能处理输入符号了？这时候要让谁来处理呢？其实这里又带来了一种不确定性，这同样是我们不希望看到的。</p>
<h3 id="3-LL-1-文法"><a href="#3-LL-1-文法" class="headerlink" title="3. LL(1) 文法"></a>3. LL(1) 文法</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>上面说了这么多东西，又要求文法不存在左递归、又要求没有回溯，还要求非终结符的 <code>First(A)</code> 和 <code>Follow(A)</code> 最好没有交集，那么是否存在某种文法可以满足所有这些条件呢？—— 有的，那就是 <code>LL(1)</code> 文法。 <code>LL(1)</code> 文法是确定的，只有基于这种确定的文法，我们才能进行确定的自顶向下分析。联系上面我们分析导致文法不确定的因素的过程，可以给出 <code>LL(1)</code> 文法的定义如下：</p>
<ul>
<li>必须不包含左递归</li>
</ul>
<ul>
<li>对于每个非终结符，它的各个右部的 First 集两两不相交</li>
</ul>
<ul>
<li>对于每个非终结符，如果它的 First 集包含 <code>ε</code> ，则它的 First 集和 Follow 集不相交</li>
</ul>
<p>因为我们前面已经经过了分析，会发现这里要理解 <code>LL(1)</code> 文法的定义，相对容易很多，而且我们也知道它为什么要这么定义，对他的来龙去脉有一个清晰的理解。</p>
<h4 id="3-2-判断"><a href="#3-2-判断" class="headerlink" title="3.2 判断"></a>3.2 判断</h4><p>那么，如何判断一个文法是否属于 <code>LL(1)</code> 文法呢？我们可以选择用定义判断，也可以结合稍后介绍的 select 集进行判断。以下面这个文法为例：</p>
<pre class="line-numbers language-js"><code class="language-js">S → aA<span class="token operator">|</span>d
A → bAS<span class="token operator">|</span>ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>① 基于定义进行判断</strong></p>
<ul>
<li>显而易见，它不存在左递归</li>
<li>分析 S 的各个右部，aA 的 First 集为 <code>{a}</code>，d 的 First 集为 <code>{d}</code>，两个集合不相交；分析 A 的各个右部，bAS 的 First 集为 <code>{b}</code>，ε 的 First 集为 <code>{ε}</code>，两个集合也不相交。所以，文法的每个非终结符的候选 First 集两两都不相交</li>
<li>A 的 First 集为 <code>{ε,b}</code> ，它的 Follow 集为 <code>{ a,d,# }</code>，两者不相交（注意不要漏掉 #，因为 <code>S → aA</code> 也是 S 和 A 之间的相关推导 ）</li>
</ul>
<p>由于该文法符合 <code>LL(1)</code> 文法的定义，所以它属于 <code>LL(1)</code> 文法。</p>
<p><strong>② 基于 select 集进行判断</strong></p>
<p>对于给定文法的每一条产生式，select 集的规则如下：</p>
<ul>
<li>如果产生式右部无法推导出 ε：该产生式的 select 集为产生式右部的 First 集</li>
<li>如果产生式右部可以推导出 ε：该产生式的 select 集为产生式右部的 First 集去除 ε ，并上产生式左部的 Follow 集</li>
</ul>
<p>求解给定文法的每一条产生式，若左部相同的产生式两两之间的 select 集不相交，则该文法属于 <code>LL(1)</code> 文法。</p>
<p>以上面为例，我们可以得到如下四条产生式：</p>
<pre class="line-numbers language-js"><code class="language-js">S → aA
S → d
A → bAS
A → ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的 select 集为：</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">select</span><span class="token punctuation">(</span>S → aA<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>aA<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>S → d<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>A → bAS<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>bAS<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>A → ε<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">First</span><span class="token punctuation">(</span>ε<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">{</span>ε<span class="token punctuation">}</span><span class="token punctuation">)</span> U <span class="token function">Follow</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>d<span class="token punctuation">,</span># <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对左部相同的产生式的 select 集，两两之间求交集：</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">select</span><span class="token punctuation">(</span>S → aA<span class="token punctuation">)</span> U <span class="token function">select</span><span class="token punctuation">(</span>S → d<span class="token punctuation">)</span> <span class="token operator">=</span> Ø
<span class="token function">select</span><span class="token punctuation">(</span>A → bAS<span class="token punctuation">)</span> U <span class="token function">select</span><span class="token punctuation">(</span>A → ε<span class="token punctuation">)</span> <span class="token operator">=</span> Ø<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>发现都是不相交的，根据上面的规则，可以判断该文法属于 <code>LL(1)</code> 文法。</p>
<h3 id="4-递归下降分析程序"><a href="#4-递归下降分析程序" class="headerlink" title="4. 递归下降分析程序"></a>4. 递归下降分析程序</h3><blockquote>
<p>这一节没有重点讲解，可以略过。</p>
</blockquote>
<p>当一个文法满足 <code>LL(1)</code> 条件时，我们可以选择构造一个不带回溯的自上而下分析程序。这个分析程序由一组递归过程组成，每个过程对应文法的一个非终结符，这种分析程序称为递归下降分析器。如果用某种高级语言写出所有递归过程，那就可以用这个语言的编译习题来产生整个分析程序了。</p>
<h4 id="4-1-扩充的巴科斯范式"><a href="#4-1-扩充的巴科斯范式" class="headerlink" title="4.1 扩充的巴科斯范式"></a>4.1 扩充的巴科斯范式</h4><ul>
<li>用花括号 <code>{α}</code> 表示闭包运算 <code>α*</code></li>
<li>用 <code>{α}_n^0</code> 表示 <code>α</code> 可以任意重复 0 次到 n 次， <code>{α}_n^0 = α^0 = ε</code></li>
<li>用方括号 <code>[α]</code> 表示 <code>{α}_1^0</code> ，即表示 <code>α</code> 的出现可有可无（等价于 <code>α|ε</code> ）</li>
</ul>
<h4 id="4-2-编写递归下降分析程序"><a href="#4-2-编写递归下降分析程序" class="headerlink" title="4.2 编写递归下降分析程序"></a>4.2 编写递归下降分析程序</h4><p>对于给定的文法，可以利用扩充的巴科斯范式进行改写：</p>
<pre class="line-numbers language-js"><code class="language-js">E → T<span class="token operator">|</span>E <span class="token operator">+</span> T
T → F<span class="token operator">|</span>T <span class="token operator">*</span> F
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i
<span class="token comment" spellcheck="true">// 改写为</span>
E → T<span class="token punctuation">{</span><span class="token operator">+</span>T<span class="token punctuation">}</span>
T → F<span class="token operator">|</span><span class="token punctuation">{</span><span class="token operator">*</span>F<span class="token punctuation">}</span>
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>PS：也可以用语法图表示改写后的结果，这会更加直观：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/9.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/9.png" alt="img"></a></p>
<p>基于改写后的文法或者是语法图，可以构造如下的递归下降分析程序（ADVANCE 表示扫描下一个输入符号，SYM 表示当前输入符号，ERROR 表示出错纠察处理程序）：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/10.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/10.png" alt="img"></a></p>
<h3 id="5-预测分析程序"><a href="#5-预测分析程序" class="headerlink" title="5. 预测分析程序"></a>5. 预测分析程序</h3><p>使用高级语言的递归过程描述递归下降分析器，只有当具有实现这种过程的编译系统时才有实际意义，构造预测分析程序是实现 <code>LL(1)</code> 分析的另一种有效方式。</p>
<h4 id="4-1-主要流程"><a href="#4-1-主要流程" class="headerlink" title="4.1 主要流程"></a>4.1 主要流程</h4><p>借助 <code>LL(1)</code> 预测分析程序，可以进行语法分析：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/3.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/3.png" alt="img"></a></p>
<p>预测分析程序的核心是借助一张分析表以及一个栈。分析表是一个 <code>M[A,a]</code> 形式的矩阵，A 表示非终结符，a 表示终结符或者 #，矩阵的每一个元素 <code>M[A,a]</code> 都存放着一条关于 A 的产生式，表示当 A 面对输入符号 a 的时候应该使用什么样的右部去进行替换；元素也可能存放一个出错标志（在表中用空白表示），这时候表示分析出错：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/4.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/4.png" alt="img"></a></p>
<p>栈中一开始放的是栈底的 # 以及栈顶的文法开始符号，在预测分析程序运行的整个过程中，栈中元素会不断发生变动：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/5.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/5.png" alt="img"></a></p>
<p>当栈顶为 A，面对输入符号 a 的时候，这时候视情况有三种可能的操作：</p>
<ul>
<li><code>A = a = #</code>，此时成功完成分析，语法分析通过</li>
<li><code>A = a ≠ #</code>，此时 A 出栈，扫描下一个输入符号</li>
<li><code>A∈V_N</code>，则根据 <code>M[A,a]</code> 到分析表中查询对应元素，该元素可能为产生式或者一个错误标志：若为产生式，则栈顶元素出栈，让产生式右部逆序依次进栈；若为错误标志，则分析出错，语法分析不通过。</li>
</ul>
<h4 id="4-2-具体分析"><a href="#4-2-具体分析" class="headerlink" title="4.2 具体分析"></a>4.2 具体分析</h4><p>在正式进行预测分析之前，还需要解决几个问题：首先，文法未必是 <code>LL(1)</code> 文法，可能需要先对文法进行处理，消除左递归和回溯；其次，需要构造一张预测分析表以用于后续的预测分析，做完这些准备工作，最后才是预测分析。我们现在以一个例子来讲解整个流程。假设给定如下文法和输入符号串：</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 文法</span>
E → E <span class="token operator">+</span> T<span class="token operator">|</span>T
T → T <span class="token operator">*</span> F<span class="token operator">|</span>F
F → i<span class="token operator">|</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 输入符号串</span>
i <span class="token operator">+</span> i <span class="token operator">*</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>符号串是否符合给定文法呢？我们试着用预测分析程序进行语法分析。</p>
<p><strong>① <code>LL(1)</code> 判断</strong></p>
<blockquote>
<p>有没有左递归？</p>
</blockquote>
<p>很明显，这个文法存在直接左递归，为了方便后续工作的开展，这里先消除左递归。根据左递归消除的规则，将原文法改写为如下的等价文法：</p>
<pre class="line-numbers language-html"><code class="language-html">E → TE'
E' → +TE'|ε
T → FT'
T' → *FT'|ε
F → i|(E)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>有没有回溯？</p>
</blockquote>
<p>尝试基于 select 集判断文法是否存在回溯。为了方便，这里先计算出 First 集和 Follow 集。</p>
<p>产生式右部的 First 集：</p>
<pre class="line-numbers language-html"><code class="language-html">First(TE') = {i,(}
First(+TE') = {+}
First(ε) = {ε}
First(*FT) = {*}
First((E)) = {(}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>非终结符的 Follow 集：</p>
<ul>
<li>从 E 到 E，存在相关推导 <code>E ⇒ E 和 E ⇒ (E)T&#39;E&#39;</code>，所以 <code>Follow(E) = { ),# }</code></li>
<li>从 E 到 E’，存在相关推导 <code>E ⇒ TE&#39;</code> 和 <code>E ⇒ TE&#39; ⇒ T+TE&#39; ⇒ T+FT&#39;E&#39; ⇒ T+(E)T&#39;E&#39; ⇒ T+(TE&#39;)T&#39;E&#39;</code>，所以 <code>Follow(E&#39;) = { ),# }</code></li>
<li>从 E 到 T，存在相关推导 <code>E ⇒ TE&#39; ⇒ Tε ⇒ T</code> ， <code>E ⇒ TE&#39;⇒ T+TE&#39;</code> ， <code>E ⇒ TE&#39;⇒ T+TE&#39;⇒ FT&#39;+TE&#39; ⇒ (E)T&#39;+TE&#39; ⇒ (TE&#39;)T&#39;+TE&#39; ⇒ (Tε)T&#39;+TE&#39;⇒ (T)T&#39;+TE&#39;</code> ，所以 <code>Follow(T) = { +,),# }</code></li>
<li>从 E 到 T’，存在相关推导 <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;ε</code> ， <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;+TE‘</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;ε ⇒ F*FT’ ⇒ F*(E)T&#39; ⇒ F*(TE&#39;)T&#39; ⇒ F*(FT&#39;E&#39;)T&#39; ⇒ F*(FT&#39;)T</code>， 所以 <code>Follow(T&#39;) = { +,),# }</code></li>
<li>从 E 到 F，存在相关推导 <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FT&#39;E&#39;</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FE&#39; ⇒ F*F</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FE&#39; ⇒ F*(E) ⇒ F*(TE&#39;) ⇒ F*(FT&#39;E&#39;) ⇒ F*(F)</code>，<code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ FT&#39;TE&#39;⇒ FT&#39;T+TE ⇒ FT&#39;FT&#39;+TE ⇒ FT&#39;F+TE</code> 所以 <code>Follow(T&#39;) = {*,#,),+}</code></li>
</ul>
<p>整个过程相当之麻烦，因为要尝试各种可能的组合，找出所有推导中每个非终结符后面可能跟着的终结符。但是我们可以稍微<strong>换个角度</strong>想一想，与其去求非终结符后面可能存在的终结符，不如先假设后面一定存在某个终结符，并尽可能地朝着那个方向进行替换。这并不会减轻我们的大部分工作，但是有目标总比没目标要来的轻松。</p>
<p>现在已经计算出 First 集和 Follow 集，接着计算各条产生式的 select 集就会轻松很多了：</p>
<pre class="line-numbers language-html"><code class="language-html">select(E → TE') = {i,(}
select(E' → +TE') = {+}
select(E' → ε) = { ε,),# }
select(T → FT') = {i,(}
select(T' → *FT') = {*}
select(T' → ε) = { ε,+,),# }
select(F → i) = {i}
select(F → (E)) = {(}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>左部相同的产生式，其 select 集两两之间不相交，所以可以确定该文法为 <code>LL(1)</code> 文法。</p>
<blockquote>
<p>若某个非终结符的 First 集存在空符号串，该 First 集和 Follow 集是否会相交？</p>
</blockquote>
<p>观察 <code>E&#39; → +TE&#39;|ε</code> 和 <code>T&#39; → *FT&#39;|ε</code> 这两条产生式，会发现 E‘ 和 T’ 这两个非终结符的 First 集存在空符号串 —— 所以要分别对 E‘ 和 T’ 求 First 集和 Follow 集，看是否会与各自的 First 集相交。</p>
<p>我们上面已经求了 Follow 集，分别是 <code>{ ),# }</code> 和 <code>{ #,),+ }</code>，这里可以求 First 集，分别是 <code>{+，ε}</code> 和 <code>{*,ε}</code>，可以看出 Follow 集和对应的 First 集不相交。</p>
<p>综上，我们已经将这个文法改写为等价的 <code>LL(1)</code> 文法。</p>
<p><strong>② 构造预测分析表</strong></p>
<p>我们在上面求出 select 集，不仅仅是为了检测文法是否属于 <code>LL(1)</code> 文法，也是为了构造预测分析表。要构造构造预测分析表，首先写好基本结构，即行头（非终结符）和列头（终结符）：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" alt="img"></a></p>
<p>如何填充矩阵的元素呢？我们把上面求出的 select 集拿过来：</p>
<pre class="line-numbers language-html"><code class="language-html">select(E → TE') = {i,(}
select(E' → +TE') = {+}
select(E' → ε) = { ε,),# }
select(T → FT') = {i,(}
select(T' → *FT') = {*}
select(T' → ε) = { ε,+,),# }
select(F → i) = {i}
select(F → (E)) = {(}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>针对每一个终结符 <code>x</code>，若终结符 <code>x</code> 存在于 <code>select(X → Y)</code> 中，则将产生式 <code>X → Y</code> 填入非终结符 <code>X</code> 对应于终结符 <code>x</code> 的矩阵元素中。再填充完所有能找到的元素之后，剩下未填充的一律留白，作为错误标志。</p>
<p>比如说，终结符 <code>i</code> 存在于 <code>select(E → TE&#39;) = {i,(}</code>，<code>select(T → FT&#39;) = {i,(}</code>，<code>select(F → i) = {i}</code> 中，那么就把 <code>E → TE&#39;</code> 填入 <code>E</code> 对应于 <code>i</code> 的矩阵元素中，把 <code>T → FT&#39;</code> 填入 <code>T</code> 对应于 <code>i</code> 的矩阵元素中，以此类推。所以，我们最终得到了如下的预测分析表：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" alt="img"></a></p>
<p><strong>③ 进行预测分析</strong></p>
<p>经过“长途跋涉”，终于可以针对输入符号串 <code>i + i * i#</code> 开始我们正式的预测分析过程了！首先准备一个栈、一个输入符号列表和一个所用产生式列表：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">…….</td>
<td align="center">…….</td>
</tr>
</tbody></table>
<p>正如之前所说，一开始栈里是 <code>#E</code>，首先输入的符号是 i，对照预测分析表，找到我们要使用的产生式：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
</tbody></table>
<p>因为栈顶元素和输入符号不等，所以栈顶元素出栈，产生式右部逆序进栈，输入符号不变。此时再对照预测分析表，找到我们要使用的产生式：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
</tbody></table>
<p>同理，栈顶元素出栈，产生式右部逆序进栈，输入符号不变，改变所用产生式：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T‘F</td>
<td align="center">i</td>
<td align="center"><code>F → i</code></td>
</tr>
</tbody></table>
<p>继续出栈和进栈：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T‘F</td>
<td align="center">i</td>
<td align="center"><code>F → i</code></td>
</tr>
<tr>
<td align="center">#E’T‘i</td>
<td align="center">i</td>
<td align="center">匹配</td>
</tr>
</tbody></table>
<p>栈顶元素和输入符号匹配，且不等于 #，此时就让栈顶元素出栈，同时扫描下一个输入符号，找到对应的产生式：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T‘F</td>
<td align="center">i</td>
<td align="center"><code>F → i</code></td>
</tr>
<tr>
<td align="center">#E’T‘i</td>
<td align="center">i</td>
<td align="center">匹配</td>
</tr>
<tr>
<td align="center">#E’T‘</td>
<td align="center">+</td>
<td align="center"><code>T&#39; → ε</code></td>
</tr>
</tbody></table>
<p>继续出栈和进栈：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T‘F</td>
<td align="center">i</td>
<td align="center"><code>F → i</code></td>
</tr>
<tr>
<td align="center">#E’T‘i</td>
<td align="center">i</td>
<td align="center">匹配</td>
</tr>
<tr>
<td align="center">#E’T‘</td>
<td align="center">+</td>
<td align="center"><code>T&#39; → ε</code></td>
</tr>
<tr>
<td align="center">#E’</td>
<td align="center">+</td>
<td align="center"><code>E&#39; → +TE&#39;</code></td>
</tr>
</tbody></table>
<p>此后的过程类似，这里就不一一展示了。在某个时刻，我们到达下面这个状态：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#E</td>
<td align="center">i</td>
<td align="center"><code>E → TE&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T</td>
<td align="center">i</td>
<td align="center"><code>T → FT&#39;</code></td>
</tr>
<tr>
<td align="center">#E’T‘F</td>
<td align="center">i</td>
<td align="center"><code>F → i</code></td>
</tr>
<tr>
<td align="center">#E’T‘i</td>
<td align="center">i</td>
<td align="center">匹配</td>
</tr>
<tr>
<td align="center">#E’T‘</td>
<td align="center">+</td>
<td align="center"><code>T&#39; → ε</code></td>
</tr>
<tr>
<td align="center">#E’</td>
<td align="center">+</td>
<td align="center"><code>E&#39; → +TE&#39;</code></td>
</tr>
<tr>
<td align="center">…….</td>
<td align="center">…….</td>
<td align="center">…….</td>
</tr>
<tr>
<td align="center">#E’</td>
<td align="center">#</td>
<td align="center"><code>E&#39; → ε</code></td>
</tr>
</tbody></table>
<p>在这个状态下继续往后执行：</p>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">输入符号</th>
<th align="center">所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">…….</td>
<td align="center">…….</td>
<td align="center">…….</td>
</tr>
<tr>
<td align="center">#E’</td>
<td align="center">#</td>
<td align="center"><code>E&#39; → ε</code></td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">#</td>
<td align="center">匹配且等于 #</td>
</tr>
</tbody></table>
<p>这时候，栈顶元素等于输入符号等于 #，说明成功完成了分析，符号串是符合该文法的。</p>
<h4 id="4-3-错误处理"><a href="#4-3-错误处理" class="headerlink" title="4.3 错误处理"></a>4.3 错误处理</h4><p>具体对错误的处理，我们可以向预测分析表中引入同步符号。针对每一个非终结符 X，如果他的 Follow 集包含终结符 x，则把矩阵对应的元素 <code>[X,x]</code> 加上同步符号，表示将 x 加入 X 的同步符号集。因此，我们得到了如下的预测分析表：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/8.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/8.png" alt="img"></a></p>
<p>这样，在进行分析的时候，如果矩阵元素还是空，则跳过当前输入符号；如果矩阵元素为 synch，则弹出栈顶非终结符；如果栈顶终结符和输入符号不匹配，则弹出栈顶终结符。</p>
<h3 id="6-更简单地构造-Follow-集和分析表"><a href="#6-更简单地构造-Follow-集和分析表" class="headerlink" title="6. 更简单地构造 Follow 集和分析表"></a>6. 更简单地构造 Follow 集和分析表</h3><p>上面构造 Follow 集和分析表存在的问题：</p>
<ul>
<li>求解 Follow 集采用的是定义推导的方式，基本上需要穷举各种可能的情况，太过繁琐</li>
<li>构造分析表之前额外求解了 Select 集，其实这不是必要的，完全可以只通过 First 集和 Follow 集构造</li>
</ul>
<p>这里补充介绍更加简便的方法。</p>
<p>首先我们的目标文法不变，还是这个：</p>
<pre class="line-numbers language-html"><code class="language-html">E → TE'
E' → +TE'|ε
T → FT'
T' → *FT'|ε
F → i|(E)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为这次不使用 Select 集，所以只需要求解非终结符的 First 集，而不是产生式右部的 First 集。这里直接写结果：</p>
<pre class="line-numbers language-html"><code class="language-html">First(E) = First(T) = First(F) = {i,(}
First(E') = {+,ε}
First(T') = {*,ε}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="6-1-构造-Follow-集"><a href="#6-1-构造-Follow-集" class="headerlink" title="6.1 构造 Follow 集"></a>6.1 构造 Follow 集</h4><p>依次使用下面的规则构造各条产生式的 Follow 集：</p>
<p>① <code>#</code> 属于 <code>Follow(S)</code>（S 表示开始符号）</p>
<p>② 遍历每一条产生式，尝试将产生式用 <code>A -&gt; αBβ</code> 的格式代替，若符合格式，则有 <code>First(β)-{ε}∈Follow(B)</code></p>
<p>③ 遍历每一条产生式，尝试将产生式用 <code>A -&gt; αB</code> 的格式代替；或者用 <code>A -&gt; αBβ</code> 且 <code>ε∈First(β)</code>代替，若符合格式，则有 <code>Follow(A)∈Follow(B)</code></p>
<p>④ 综上上面所求的所有 Follow 集</p>
<p><strong>以上面的文法为例，尝试构造 Follow 集：</strong></p>
<p>① <code>#</code> 属于 <code>Follow(E)</code></p>
<p>② 遍历每一条产生式：</p>
<ul>
<li><code>E → TE&#39;</code>：E 对应 A，T 对应 B，E‘ 对应 β，所以 <code>First(E&#39;)-{ε}∈Follow(T)={+}</code></li>
<li><code>E&#39; → +TE&#39;|ε</code>：E’ 对应 A，T 对应 B（不能让 E‘ 对应 B，否则 β 为空，无意义），E’ 对应 β，后面的过程和上一条推导重复了，故忽略本条产生式</li>
<li><code>T → FT&#39;</code>：T 对应 A，F 对应 B，T‘ 对应 β，所以 <code>First(T&#39;)-{ε}∈Follow(F)={*}</code></li>
<li><code>T&#39; → *FT&#39;|ε</code>：T’ 对应 A，F 对应 B，T’ 对应 β，后面的过程和上一条推导重复了，故忽略本条产生式</li>
<li><code>F → (E)|i</code>：F 对应 A，E 对应 B，）对应 β，所以 <code>First())∈Follow(E)={)}</code>，加上在 ① 中求出的 <code>Follow(E)</code>，故 <code>Follow(E)={ #,) }</code></li>
</ul>
<p>③ 遍历每一条产生式：</p>
<ul>
<li><code>E → TE&#39;</code>：E 对应 A，T 对应 α，E‘ 对应 B，所以 <code>Follow(E)∈Follow(E&#39;)={ #,) }</code>；换种方式，E 对应 A，T 对应 B，E’ 对应 β，且 <code>ε∈First(E&#39;)</code>，所以 <code>Follow(E)∈Follow(T)={+,#,)}</code>；或者，E 对应 A，T 对应 α，E‘ 对应 B，且 <code>ε∈First(ε)</code>，所以 <code>Follow(E)∈Follow(E&#39;)={ #,) }</code>，这和最开始的推导重复了，故忽略之</li>
<li><code>T → FT&#39;</code>：T 对应 A，F 对应 α，T‘ 对应 B，所以 <code>Follow(T)∈Follow(T&#39;)={+}</code>；换种方式，类似上面的，可以推导得到 <code>Follow(F)={ *,+,),# }</code>，以及得到 <code>Follow(T&#39;)={ +,),# }</code></li>
<li><code>E&#39; → +TE&#39;|ε</code>：E’ 对应 A，+T 对应 α，E’ 对应 B，所以 <code>Follow(E&#39;)∈Follow(E&#39;)</code>，忽略之；换种方式，E’ 对应 A，+ 对应 α，T 对应 B，E‘ 对应 β，因为 <code>Follow(E&#39;)</code> 本身已经属于<code>Follow(T)</code>，故忽略之</li>
<li><code>T&#39; → *FT&#39;|ε</code>：整个过程类似上面的，没有得到新的推导结果，故忽略之</li>
<li><code>F → (E)|i</code>：F 对应 A，<code>(</code> 对应 α，E 对应 B， <code>)</code> 对应 β，但是 <code>)</code> 无法推导得到 <code>ε</code>，所以忽略之</li>
</ul>
<p>④ 综上，Follow 集如下：</p>
<pre class="line-numbers language-html"><code class="language-html">Follow(E) = Follow(E’) = { ),# }
Follow(T) = Follow(T’) = { +,),# }
Follow(F) = { *,+,),# }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="6-2-构造分析表"><a href="#6-2-构造分析表" class="headerlink" title="6.2 构造分析表"></a>6.2 构造分析表</h4><p>要构造构造预测分析表，首先写好基本结构，即行头（非终结符）和列头（终结符）：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" alt="img"></a></p>
<p>如何填充矩阵的元素呢？我们把上面求出的 First 集和 Follow 集拿过来：</p>
<pre class="line-numbers language-html"><code class="language-html">First(E) = First(T) = First(F) = {i,(}
First(E') = {+,ε}
First(T') = {*,ε}

Follow(E) = Follow(E’) = { ),# }
Follow(T) = Follow(T’) = { +,),# }
Follow(F) = { *,+,),# }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>查看 <code>[E,i]</code> 对应的单元格，将 <code>E → TE&#39;</code> 填入，查看 <code>[E,(]</code> 对应的单元格，同样将 <code>E → TE&#39;</code> 填入</li>
<li>查看 <code>[T,i]</code> 和 <code>[T,(]</code> 对应的单元格，这里和上面一样</li>
<li>查看 <code>[F,i]</code> 对应的单元格，将 <code>F → i</code> 填入；查看 <code>[F,(]</code> 对应的单元格，将 <code>F → (E)</code> 填入</li>
<li>查看 <code>[E’,+]</code> 对应的单元格，将 <code>E‘ → +TE’</code> 填入；查看 <code>[E‘,ε]</code> 对应的单元格，<strong>注意这里遇到了 ε，转到 Follow 集查看</strong>，来到 <code>Follow(E’)={ ),# }</code>，将 <code>[E’,)]</code> 和 <code>[E&#39;,#]</code> 对应的单元格都填入 <code>E&#39;-&gt;ε</code></li>
</ul>
<p>总之，优先以 First 集为准，查看每个单元格，并将相应的产生式放进去，若遇到 <code>ε</code>，则跳转到 Follow 集查看。后面的情况都是类似的，这里就不一一说明了，最后还没填充的单元格一律空着即可。</p>
<p>所以，我们最终得到了如下的预测分析表：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" target="_blank" rel="noopener"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" alt="img"></a></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">YuHong Sun</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://Yuki-Asuuna.github.io/2020/09/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/">http://Yuki-Asuuna.github.io/2020/09/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">YuHong Sun</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
                                    <span class="chip bg-color">编译原理</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2020-09-25T10-19-05',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2020/09/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="编译原理第三章笔记——语法分析">
                        
                        <span class="card-title">编译原理第三章笔记——语法分析</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            编译原理第三章笔记——语法分析下面是这篇笔记的思维导图：

注意：以下的所有分析基于上下文无关文法。
1. 语法分析1.1 语法分析器在词法分析中，我们扫描输入源程序的每个字符，得到多种类型的单词（token），一系列的单词就构成了一条单词
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-09-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            YuHong Sun
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
                        <span class="chip bg-color">编译原理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/09/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="编译原理第二章笔记">
                        
                        <span class="card-title">编译原理第二章笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            编译原理第二章笔记——词法分析1. 字母表1.1 定义​    字母表（Alphabet）是一个有穷符号集合，可以是字母、数字或标点符号。用符号$\sum$表示。
1.2 运算​    乘积运算$\sum_1 \sum_2={xy|x\in
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-09-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            YuHong Sun
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
                        <span class="chip bg-color">编译原理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020# 年份</span>
            <a href="/about" target="_blank">YuHong Sun</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">91.6k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Yuki-Asuuna" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:10174503104@stu.ecnu.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=501263359" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 501263359" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/xi-lian-chuan-lu-xia" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/xi-lian-chuan-lu-xia" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>

</html>
